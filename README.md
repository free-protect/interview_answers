# Python

## Последовательности

### 1. Що таке Інтерпретована мова програмування? Що таке інтерпретатор і як він працює в Python?

Інтерпретована мова програмування — мова програмування, в якій початковий код програми не перетворюється попередньо
повністю у машинний код для виконання, як у компільованих мовах, а виконується рядок за рядком з допомогою спеціальної
програми-інтерпретатора.
Головні відмінності між компільованими й інтерпретованими мовами:

- швидкість виконання програми, компільованої в машинний код, перевершує швидкість інтерпретованої програми, як правило,
  в десятки і сотні разів;
- у разі використання компілятора, при внесенні змін у початковий код програми, перш ніж ці зміни можна буде побачити в
  роботі програми, необхідно виконати компіляцію сирцевого тексту.

### 2. Що таке статична та динамічна типізація і в чому це проявляється у Python?

Мова має статичну типізацію, якщо тип змінної відомий під час компіляції, а не виконання. Типовими прикладами таких мов
є Ada, C, C++, C#, JADE, Java, Fortran, Haskell, ML, Pascal та Scala.

Динамічна перевірка типів – це процес підтвердження типобезпеки програми під час виконання. Типовими прикладами
динамічно типізованих мов є Groovy, JavaScript, Lisp, Lua, Objective-C, PHP, Prolog, Python, Ruby, Smalltalk та Tcl.
Перевірка типу – це процес перевірки та застосування обмежень типів. Зазвичай виконується компілятором чи
інтерпретатором під час компіляції чи виконання.
Оголошення типу
Статична перевірка: Усі типи змінних мають бути явно вказані, оскільки ця інформація потрібна під час компіляції.

Наприклад Java: float f = 0.5;

Динамічна перевірка: явне оголошення не потрібне, оскільки тип надається змінною під час виконання.

Наприклад у Python: f = 0.5

Продуктивність
Статична перевірка: додаткова обробка під час компіляції, але вища продуктивність під час виконання.

Динамічна перевірка: ефективніші компілятори/інтерпретатори, але перевірка типів під час виконання впливає на
продуктивність.

Гнучкість
Статична перевірка: менш схильна до помилок під час виконання, але забезпечує меншу гнучкість для програміста.

Динамічна перевірка: забезпечує більшу гнучкість, але більш схильна до помилок під час виконання.

Сильно типізована мова — це така мова, в якій змінні прив'язані до конкретних типів даних, і яка видасть помилку
типізації у разі розбіжності очікуваного та фактичного типів, коли б не проводилася перевірка.

### 3. Які типи даних у Python вам відомі?

До основних вбудованих типів в Python відносяться:

Numeric Type – числа:

- int – ціле число;
- float – число з плаваючою точкою (дійсне число);
- complex – комплексне число.
  Sequence Type – послідовності:
- list – список;
- tuple – кортеж;
- range – діапазон.
  Text Sequence Type – рядки;
  str – рядки.
  Binary Sequence Types – бінарні послідовності:
  bytes – байти;
  bytearray – масиви байт 24;
  memoryview – спеціальні об’єкти для доступу до внутрішніх даних об’єкта через protocol buffer.
  Set Types – множини:
  set – множина;
  frozenset – незмінювана множина.
  Mapping Types – словники:
  dict – словник.

### 4. Чим кортеж відрізняється від списку?

Кортежі та списки – це вбудовані структури даних. Це контейнери, де можна зберігати впорядковану колекцію з одного або
декількох елементів.
Списки і кортежі можуть містити елементи, що повторюються, а значення можуть дублюватися, з'являючись кілька разів.
Елементи та списків, і кортежів доступні за індексом
Чим кортеж відрізняється від списку?
Кортежі, на відміну від списків, незмінні

### 5. У яких випадках краще використовувати кортеж, а у яких – список?

Кортежі зручно використовувати, якщо ви хочете, щоб дані у вашій колекції були доступні тільки для читання та завжди
залишалися незмінними та постійними.
Завдяки гарантії незмінності кортежі можуть використовуватися в словниках і множинах, для яких потрібно, щоб елементи,
що містяться в них, мали незмінний тип.

Коли використовувати списки?
З іншого боку, списки можна легко редагувати та модифікувати, тому що вони змінюються.

Ви можете додавати елементи до списку, видаляти елементи зі списку, переміщати елементи та замінювати їх.

Це означає, що довжина та розмір списків збільшується та зменшується протягом життєвого циклу програми.

Списки корисні, коли ви хочете, щоб ваші дані були гнучкими або щоб за необхідності їх можна було змінити.

### 6. Як ви поясните людині, що таке множина set()?

Множина set() — це «мішок», що містить унікальні невпорядковані значення.
Одна множина може містити значення будь-яких типів.
Якщо у вас є дві множини, ви можете здійснювати над ними будь-які стандартні операції, наприклад, об'єднання, перетин та
різницю.

### 7. Що таке словники та як вони працюють?

Словник — це контейнер, який зберігає пари ключ-значень. Ключем може бути будь-який незмінний тип даних Python (число,
рядок, кортеж, ін.).
Неможливо використовувати у якості ключа списки, словники, множини або будь-які інші змінювані типи даних.
Значенням словника може бути будь-який тип даних Python, включаючи призначені для користувача типи.

Методи словників
Деякі найчастіше використовувані методи словників:

- pop(key) — повертає значення елементу і видаляє пару ключ-значення із словника
  chars = {'a': 1, 'b': 2}
  b_num = chars.pop('b')
  print(chars)  # {'a': 1}
  print(b_num)  # 2

- update(another_dict) — розширює словник значеннями з іншого словника

```bash
chars = {'a': 1, 'b': 2}
chars.update({"c": 3})
print(chars)  # {'a': 1, 'b': 2, "c": 3}
```

- clear() — очищає словник, не створюючи нового

```bash
chars = {'a': 1, 'b': 2}
chars.clear()
print(chars)  # {}
```

- copy() — повертає копію словника

```bash
chars = {'a': 1, 'b': 2}
chars_copy = chars.copy()
chars_copy == chars  # True
```

- get(key[, default]) — не викликає виключення, якщо ключа немає в словнику, повертає default, за замовчуванням
default=None.

```bash
chars = {'a': 1, 'b': 2}
c_idx = chars.get('c', -1)
print(c_idx)  # -1
```

### Як працюють типи даних хешмап, зв'язаний список, двозв'язковий список, масив?

    Хеш-таблиці – це тип структури даних, у якій адресу чи значення індексу елемента даних генеруються з хеш-функції. 
Це прискорює доступом до даних, оскільки значення індексу веде себе як ключ значення даних. 
Іншими словами, у хеш-таблиці зберігаються пари ключ-значення, але ключ генерується за допомогою функції хешування.
Таким чином, функція пошуку та вставки елемента даних стає набагато швидше, оскільки самі значення ключів стають індексом масиву, в якому зберігаються дані.
У Python типи даних Dictionary представляють реалізацію хеш-таблиць. Ключі у словнику задовольняють такі вимоги.

- Ключі словника є хешовані, тобто генеруються хеш-функцією, яка генерує унікальний результат для кожного унікального значення, переданого хеш-функції.
- Порядок елементів даних у словнику не фіксований.
Таким чином, ми бачимо реалізацію хеш-таблиці з використанням словникових типів даних.


    Зв'язний список у Python є структурою елементів інформації, які зв'язуються між собою посиланнями. 
При цьому кожен елемент списку зазвичай містить той самий тип інформації, який є специфічним для цього списку. 
Кожен окремий елемент списку називається вузлом.
Залежно від виду зв'язку між вузлами, зв'язкові списки можуть бути 2-х видів:

- однозв'язковий список Python — у кожному окремому вузлі такого списку міститься посилання (покажчик) лише наступний вузол;

- двозв'язковий – у кожному окремому вузлі такого списку міститься посилання на наступний та попередній вузли.

Python — це послідовність вузлів інформації, де кожен окремий вузол вказує лише на наступний вузол. 
Такий список можна легко дослідити від початку до кінця списку. У зворотному порядку дослідити перелік дуже непросто.
Він зручний, коли потрібно зберегти невизначену кількість інформації, пов'язаної між собою. 
Додавати новий вузол у зв'язковий список Python легше та «дешевше», якщо порівнювати навіть із динамічним масивом.
Робота з двозв'язним списком практично ідентична, з тією лише різницею, що потрібно брати до уваги наявність двох покажчиків в одному вузлі, адже кожен вузол у двозв'язному списку вказує на наступний вузол і попередній.



    Масив – це структура даних, у якій зберігаються значення одного типу. У Python це основна відмінність між масивами та списками.

Хоча списки Python можуть містити значення, що відповідають різним типам даних, масиви Python можуть містити тільки значення, що відповідають одному і тому ж типу даних.


### 9. Що таке О (о-велике)? Навіщо та як використовується?

Це спосіб виміряти, скільки часу виконуватиметься алгоритм і наскільки добре він масштабується щодо розміру набору даних. 
Загалом, "О" - велике служить для вимірювання ефективності алгоритмів.

- O(1) - постійний час
Якщо алгоритм має постійну тимчасову складність, значить, розмір переданих даних ніяк не впливає на його продуктивність. 
Час виконання залишиться незмінним, який набір даних ви йому не передали. 
Тобто це може бути список із 5 елементів, а може бути і з тисячі — не важливо. Алгоритм з такою нотацією дуже масштабований.
Допустимо, у нас є масив чисел і ми хочемо знайти другий елемент у цьому списку. Не важливо, наскільки довгий наш список: пошук другого елемента завжди займатиме однаковий час.

- O(log n) - логарифмічний час
Якщо алгоритм логарифмічна тимчасова складність, це означає, що час виконання залежатиме від логарифму розміру вхідних даних. 
Хорошим прикладом може бути бінарний пошук. Ви послідовно ділите набір даних надвоє, поки досягнете потрібної точки.

- O(n) — линейное время
Линейная временная сложность алгоритма означает, что время его работы находится в прямой зависимости от размера входящих данных. 
Если количество элементов наборе данных растет, пропорционально растет и время работы.

- O(n log n) - лінійно-логарифмічний час
Якщо тимчасова складність алгоритму описується лінійно-логарифмічною функцією, то, як ви можете здогадатися, вона займає проміжне положення між лінійною та логарифмічною складністю.
У такому алгоритмі теж застосовується підхід «поділяй і володарюй», як у алгоритмах з логарифмічною складністю. 
Але тут набір даних спочатку розбивається на підписки, що складаються максимум із двох елементів (тобто на пари).

- O(n^2) - квадратичний час
Квадратична тимчасова складність - це коли продуктивність алгоритму прямо пропорційна розміру вхідних даних у квадраті. 
Простіше кажучи, це лінійна часова складність у квадраті.
Якщо, наприклад, у наборі даних є 2 елемента, під час роботи алгоритму буде виконано 4 операції. Якщо в наборі 4 елементи, то операцій буде 16. При 6 елементах буде 36 операцій і так далі.

- O(2^n) - експоненційний час
Експонентну тимчасову складність ми можемо спостерігати в алгоритмах, де кількість обчислень подвоюється при додаванні кожного нового елемента в набір даних. 
Так відбувається, наприклад, у брутфорс-рішеннях з використанням рекурсії. 
На невеликих наборах даних все працює добре, але зі збільшенням числа елементів у наборі час виконання може вийти з-під контролю.

- O(n!) - факторіальний час
Факторіальна тимчасова складність - це коли кількість обчислень в алгоритмі приростає факторіально в залежності від розміру набору даних. 
Це, мабуть, найгірший тип тимчасової складності, тому що кількість операцій зростає до астрономічних меж навіть за невеликого збільшення набору даних.

### 10.Яка складність вставки, вилучення, пошуку елементів у словнику та списку?
 - Список (list)
Список є однією з найважливіших структур даних в Python. Можна використовувати списки для створення стека чи черги. 
Списки – це впорядковані та змінювані колекції, які можна оновлювати за бажанням.

Операції списку та їх часова складність:
- Вставка - O(n).
- Отримання елемента -  O(1)
- Видалення елемента - O(n)
- Прохід - O(n).
- Отримання довжини - O(1)

Словник (dict)
Словник – це колекція пар ключ-значення. Ключі у словнику унікальні, щоб запобігти колізії елементів. 
Це надзвичайно корисна структура даних.
Словники індексуються за ключами, які можуть бути рядками, числами чи навіть кортежами з рядками, числами чи кортежами. 
Над словником можна виконати ряд операцій, таких як збереження значення для ключа, вилучення елемента на основі ключа або ітерація по елементах і так далі.

Операції зі словниками та їх часова складність:
Тут ми вважаємо, що ключ використовується для отримання, встановлення чи видалення елемента.

- Отримання елемента - O(1)
- Встановлення елемента - O(1)
- Видалення елемента - O(1)
- Прохід за словником - O(n)


Множина (set)
Багато також є одними з найбільш використовуваних типів даних в Python. Множина (set) є невпорядкованою колекцією. 
Множина (set) не допускає дублювання, і, отже, кожен елемент у багатьох унікальний. 
Багато підтримує set математичних операцій, таких як об'єднання, різницю, перетин і так далі.

Операції з множинами та їх часова складність: 
- Перевірити наявність елемента у множині: O(1).
- Відмінність множини A від B: O(довжина A).
- Перетин множин A та B: O(мінімальна довжина A або B).
- Об'єднання множин A та B: O(N) , де N це довжина (A) + довжина (B).

### 11. Що таке функції та навіщо вони потрібні?
Функції – це фрагменти програми, які багаторазово використовуються. 
Вони дозволяють дати ім'я певному блоку команд для того, щоб згодом запускати цей блок за вказаним ім'ям у будь-якому місці програми і скільки завгодно разів. 
Це називається викликом функції.
Функції визначаються за допомогою зарезервованого слова def. 
Після цього слова вказується ім'я функції, за яким йде пара дужок, у яких можна вказати імена деяких змінних, та заключна двокрапка в кінці рядка. 
Далі слідує блок команд, що складають функцію.


### 12. Які аргументи мають функції?


Аргументи бувають позиційні та ключові.
```bash
def summ(a, b):
    return a + b
```
- Позиційні:
```bash
summ(1, 2)
```
- Ключові:
```bash
summ(a=1, b=2)
```
Незалежно від того, як параметри створені, при виклику функції їм можна передавати значення як ключові і як позиційні аргументи. 
При цьому обов'язкові параметри треба передати у будь-якому випадку, будь-яким способом (позиційними чи ключовими), а необов'язкові можна передавати, можна ні. 
Якщо передавати, то теж у будь-який спосіб.
Іноді буває необхідно визначити функцію, здатну приймати будь-яку кількість параметрів. Цього можна досягти за допомогою зірочок:
Коли ми оголошуємо параметр зі зірочкою (наприклад, *numbers), всі позиційні аргументи, починаючи з цієї позиції до кінця, будуть зібрані в кортеж під ім'ям numbers. 
Аналогічно, коли ми оголошуємо параметри із двома зірочками (**phone_book), всі ключові аргументи, починаючи з цієї позиції до кінця, будуть зібрані в словник під ім'ям phone_book.

### 13. Що таке розпакування колекцій?

Розпакування у змінні
Розпакування кортежів
Кортеж можна розпакувати в окремі елементи:
a, b = (1, 2)
Але якщо в кортежі буде більше значень, ніж змінних, то буде помилка:
Можна скористатися оператором розпакування *:
a, *b = (1, 2, 3, 4)
В результаті перший елемент кортежу буде присвоєно першою змінною a, а всі інші елементи (вже у вигляді списку) змінної b.
Також можна зробити і навпаки

Упаковка у функціях
Операторами * та ** також зручно користуватися і у функціях. Це дозволяє викликати функцію з довільною кількістю позиційних аргументів та іменованих аргументів.
def my_function(*args, **kwargs):
Після виклику функції ми отримали кортеж args позиційних аргументів та словник kwargs іменованих аргументів.

### 14. Що таке винятки? Які вони бувають? Як їх використати?
Виключення у Python — це помилка на рівні інтерпретатора, 
викликана неможливістю виконати той або інший оператор з яких-небудь причин (змінна не існує, 
синтаксична помилка, відсутній атрибут, операція ділення на нуль і т.п.).

Винятки (exceptions) - ще один тип даних у python. Винятки необхідні для того, щоб повідомляти програміста про помилки.
Розглянемо ієрархію вбудованих у python винятків, хоча іноді вам можуть зустрітися й інші, оскільки програмісти можуть створювати власні винятки.
Винятки:
- BaseException - базовий виняток, від якого беруть початок всі інші
- AttributeError - об'єкт не має атрибуту (значення або методу).
- ImportError - не вдалося імпортувати модуль або його атрибут.
- LookupError - некоректний індекс чи ключ
- MemoryError - недостатньо пам'яті.
- IndexError - індекс не входить до діапазону елементів.
- KeyError - неіснуючий ключ (у словнику, множині або іншому об'єкті).
- Warning – попередження.


Механізм обробки виключень
Для обробки виключень існує оператор try ... except .... 
Синтаксично, цей оператор розпочинається з ключового слова try: (спробувати) та продовжується блоком коду, в якому ми чекаємо, що може статися помилка.
Далі йде блок обробки виключень except (окрім), де можна вказати одне або більше за виключення. 
Якщо одне з вказаних виключень станеться, то виконається наступний блок коду.
Цей блок не обов'язковий, але найчастіше потрібний. Він виконається, якщо станеться вказане виключення (одне із них, якщо їх декілька).
Якщо помилки можуть бути різні і обробляти їх треба теж по-різному, то можна додати декілька блоків except, у кожному вказати свою помилку і що робити, якщо вона станеться.
Потім йде необов'язковий блок, який розпочинається з ключового слова else. Цей код виконається, тільки якщо виключень не сталося.
Останнім йде необов'язковий блок коду, який розпочинається з ключового слова finally, він виконається у будь-якому разі, незалежно від того, були помилки або ні.
Виключення у Python — це дуже потужний інструмент, який часто використовується для управління потоком виконання, а не тільки для обробки помилок. 
У динамічних мовах ніколи не можна бути на 100% упевненим в тому, що користувач ввів значення коректного типу або що інше застосування не повернуло None замість int, наприклад.


### 15. Що таке ООП? На яких концепціях стоїть ООП?

Об'єктно-орієнтоване програмування (ООП) - парадигма програмування, в якій основними концепціями є поняття об'єктів та класів.
Клас - тип, що описує пристрій об'єктів. Об'єкт – це екземпляр класу. Клас можна порівняти з кресленням, яким створюються об'єкти.
Принципи ООП
Усі об'єктно-орієнтоване програмування будується на чотирьох поняттях.

Анотація. При створенні класу ми спрощуємо його до тих атрибутів і методів, які потрібні в цьому конкретному коді, не намагаючись описати його і відкидаючи все другорядне. 
Скажімо, всі кішки теоретично вміють полювати, але якщо наша програма не призначена для лову мишей, то й прописувати цей метод нема чого.

Інкапсуляція. Доступ до даних об'єкта повинен контролюватись, щоб користувач не міг змінити їх у довільному порядку та щось поламати. 
Тому для роботи з даними програмісти пишуть публічні методи, які становлять інтерфейс об'єкта.


Наслiдуваання. Класи можуть передавати свої атрибути та методи класам-нащадкам. Наприклад, ми хочемо створити новий клас «домашня кішка». Вона практично ідентична класу «кішка», але в неї з'являються нові атрибути «господар» та «кличка», а також метод «клянчити смакота». 
Достатньо оголосити «домашню кішку» спадкоємцем «кішки» і прописати нові атрибути та методи — решта функціональності перейде від батька до нащадка.

Поліморфізм. Цей принцип дозволяє застосовувати ті самі команди до об'єктів різних класів, навіть якщо вони виконуються по-різному. 
Наприклад, крім класу "кішка", у нас є ніяк не пов'язаний з ним клас "папуга" - і у обох є метод "спати". 
Незважаючи на те, що кішки та папуги сплять по-різному (кішка згортається клубком, а папуга сидить на жердинці), для цих дій можна використовувати одну команду.

### 16. Пояснити поняття класу та об'єкта (примірника).
Клас - тип, що описує пристрій об'єктів. Об'єкт – це екземпляр класу. Клас можна порівняти з кресленням, яким створюються об'єкти.
Класи — це структура мови програмування, яка дозволяє об'єднати в рамках однієї сутності змінні різних типів (поля) та функції (методи). 
Справа в тому, що майже все у Python — це об'єкт класу

Наочною метафорою для класів і об'єктів може бути форма для випічки печива і печиво. 
Клас — це форма, яка задає суть об'єкту, які поля він містить і як можна оперувати з цими полями. 
А об'єкт класу — це печиво, воно обов'язково буде заданої класом форми, але начинка кожної печенюшки може бути різною.
Таким чином клас — це форма для випікання, а ось готове печиво — це об'єкти класу.

### 17. Що таке інкапсуляція? Написати приклад.

Інкапсуляція - обмеження доступу до компонентів (методів і змінних). Інкапсуляція робить деякі компонент доступними тільки всередині класу.
Інкапсуляція в Python працює лише на рівні угоди між програмістами про те, які атрибути загальнодоступні, а які — внутрішні.
- Поодиноке підкреслення (_) на початку імені атрибута говорить про те, що змінна або метод не призначений для використання поза методами класу, проте атрибут доступний за цим ім'ям.
```bash
class A:
    def _private(self):
        print("Це приватний метод!")

```
- Подвійне підкреслення (__) на початку імені атрибута дає великий захист: атрибут стає недоступним для цього імені.

```bash
class B:
    def __private(self):
      print("Это приватный метод!")
```
Однак повністю це не захищає, тому що атрибут все одно залишається доступним під ім'ям _Ім'яКласу__Ім'яАтрибута:


### 18. Що таке Наслiдування? Написати приклад.
Наслiдуваннядозволяє виділити загальну для кількох класів поведінку та винести її в окрему сутність. 
Тобто успадкування є засобом перевикористання коду (code reuse) - використання існуючого коду для вирішення нових завдань!

Наслiдування дозволяє отримати новий клас, який трохи відрізняється від старого. 
При цьому нам не потрібно мати доступ до коду вихідного класу, а значить, за допомогою успадкування ми можемо адаптувати (використовувати повторно) під наші завдання, зокрема й чужі класи!
```bash
class Human:
    name = ''
    def voice(self):
        print(f"Hello! My name is {self.name}")


class Developer(Human):
    field_description = "My Programming language"
    language = ""
    def make_some_code(self):
        return f"{self.field_description} is {self.value}"


class PythonDeveloper(Developer):
    value = "Python"


class JSDeveloper(Developer):
    value = "JavaScript"


p_dev = PythonDeveloper()
p_dev.name = 'Bob'
p_dev.voice()   # Hello! My name is Bob
p_dev.make_some_code()  # My Programming language is Python


js_dev = JSDeveloper()
js_dev.make_some_code()  # My Programming language is JavaScript
```

У цьому прикладі ми створили батьківський клас Human, який визначив, що у всіх є ім'я та метод voice.

Далі ми розширили функціонал класу Human та створили клас Developer, який успадковується від Human і додає йому поля field_description та language і метод make_some_code. 
І щоб реалізувати функціонал розробника конкретною мовою, ми зробили два класи PythonDeveloper та JSDeveloper. Тепер якщо ми захочемо додати функціонал у всі дочірні для Human класи, то для цього можна додати потрібні атрибути в Human і вони автоматично з'являться і в PythonDeveloper, і JSDeveloper. Якщо потрібно розширити функціонал всіх розробників, то можна додати потрібні атрибути до класу Developer. І якщо треба додати особливу поведінку класу розробників конкретною мовою, то можна додати або змінити атрибути класів PythonDeveloper або JSDeveloper.

Таким чином у коді має бути лише одне місце, де визначено поведінку об'єкту. І якщо нам треба отримати інший об'єкт, який має цю поведінку і якісь свої особливості, ми можемо успадковуватись від класу з потрібними нам спільними атрибутами та додати унікальні.

Цей підхід дозволяє писати менше коду та структурувати дані, створюючи моделі реальних об'єктів з їх характеристиками (полями) та поведінкою (методами).

### 19. Чи буває в Python множинне спадкування? Як ти ставишся до цього факту?
Успадкування — це дуже потужний інструмент. Наслідувати можна не тільки від одного класу, а можна одразу від кількох. 
Таким чином можна отримувати об'єкти, що поєднують у собі властивості багатьох класів. 

### 20. Якщо в кількох класів-батьків є методи з однаковими назвами, то який із них буде викликаний у спадкоємця?
Тут має виникнути питання, а що буде, якщо кілька класів мають атрибути з однаковим ім'ям?
Для відповіді на це питання треба зрозуміти, як Python шукає атрибути (поля або методи) в об'єктах. 
Власне, це є MRO (Method Resolution Order). MRO у Python працює наступним чином:

- Шукає атрибут серед атрибутів самого класу. Саме завдяки цьому, ви можете "перевизначати" батьківські атрибути.
- Шукає атрибут у першого з батьків (той, що вказано першим у списку батьків).
- Шукає атрибут у наступного батька у списку батьків, доки такі є.
- Шукає атрибут у батьках першого батька.
- Повторює п.4 для всіх батьків.
- Викликає виключення, що атрибут не знайдено.
Пошуки закінчуються, як тільки атрибут знайдено.

### 21. Що таке поліморфізм? Написати приклад.
Поліморфізм - різна поведінка одного й того самого методу в різних класах. 
Наприклад, ми можемо скласти два числа і можемо скласти два рядки. 
При цьому отримаємо різний результат, оскільки числа та рядки є різними класами.

Качина типізація — це механізм властивий Python, який дозволяє використовувати будь-які об'єкти один замість іншого, аби в обох були потрібні методи та поля. 
Качиною ця типізація називається від приказки: "Якщо крякає як качка, плаває як качка і літає як качка, це качка". Це добре відображає суть підходу, реалізованого у Python. 
Ні інтерпретатор не перевіряє, що на функцію або метод був переданий об'єкт потрібного або дочірнього класу, достатньо щоб у об'єкта були потрібні методи і все буде працювати.
```bash
class Mammal:
    phrase = ''
    def voice(self):
        return self.phrase


class Dog(Mammal):
    phrase = 'Bark!'



class Cat(Mammal):
    phrase = 'Meow!'


class Chupakabra:
    def voice(self):
        return 'Whooooo!!!'


class Recorder:
    def record_animal(self, animal):
        voice = animal.voice()
        print(f'Recorded "{voice}"')


r = Recorder()
cat = Cat()
dog = Dog()
strange_animal = Chupakabra()

r.record_animal(cat)            # Recorded "Meow!"
r.record_animal(dog)            # Recorded "Bark!"
r.record_animal(strange_animal) # Recorded "Whooooo!!!"
```

В цьому прикладі ми створили батьківський клас Mammal, у якого є метод voice та два дочірніх до нього Dog та Cat. 
Клас Record приймає на вхід методу record_animal об'єкт animal і викликає у нього метод voice, щоб вивести результат виконання voice у консоль. 
При цьому є клас Chupakabra, у якого теж є метод voice, та хоч він і не успадковується від Mammal, але об'єкти цього класу так само можна передавати в record_animal. 
Головне, щоб атрибут називався так само і приймав ті ж аргументи (якщо це метод).

### 22. Що таке staticmethod?

@staticmethod — використовується для створення методу, який нічого не знає про клас чи екземпляр, через який він був викликаний. 
Він просто отримує передані аргументи, без неявного першого аргументу, і його визначення незмінне через спадкування.
Простіше кажучи, @staticmethod - це начебто звичайної функції, визначеної всередині класу, 
яка не має доступу до екземпляра, тому її можна викликати без створення екземпляра класу.

### 23. Чим статичнийметод відрізняється від простої функції?

Статичні методи працюють як звичайні функції, але належать до області імен класу. Вони не мають доступу ні до самого класу, ні до його екземплярів.
Статичний метод допомагає досягти інкапсуляції в класі, оскільки він не знає про стан поточного екземпляра. 
Крім того, статичні методи роблять код більш читабельним і повторно використовуваним, 
а також зручнішим для імпорту порівняно зі звичайними функціями, оскільки кожну функцію не потрібно імпортувати окремо.

### 24. Коли будемо використовувати статичнийметод, а коли просту функцію?

### 25. Що таке classmethod? У чому його особливості? Коли застосовується?
@classmethod - це метод, який отримує клас як неявний перший аргумент, так само, як звичайний метод екземпляра отримує екземпляр. 
Це означає, що ви можете використовувати клас та його властивості всередині цього методу, а не конкретного екземпляра.
Простіше кажучи, @classmethod - це звичайний метод класу, що має доступ до всіх атрибутів класу, через який він був викликаний. 
Отже, classmethod - це метод, який прив'язаний до класу, а не до екземпляра класу.
Коли використовувати classmethod?
@classmethod використовується, коли вам потрібно отримати методи, що не належать до будь-якого конкретного екземпляра, але тим не менш якимось чином прив'язані до класу. 
Найцікавіше те, що їх можна перевизначити дочірніми класами.
Тому, якщо ви хочете отримати доступ до якості класу в цілому, а не до якості конкретного екземпляра цього класу, використовуйте класметод.


### 26. Що таке магічні методи та за що вони відповідають?

Що таке магічні методи? Вони все в об'єктно-орієнтованому Пітон. 
Це спеціальні методи, за допомогою яких ви можете додати до ваших класів магію. 
Вони завжди обрамлені двома нижніми підкресленнями (наприклад, __init__ або __lt__). 
Ще вони не так добре документовані, як хотілося б. Усі магічні методи описані в документації, але дуже безладно майже без будь-якої організації. 
Тому, щоб виправити те, що я сприймаю як нестачу документації Пітона, я збираюся надати більше інформації про магічні методи, написаної зрозумілою мовою та рясно забезпеченою прикладами. 
Сподіваюся, це керівництво вам сподобається.

### 27. Що таке конструктор об'єктів у Python і з чого він складається і як працює?

Python метод __init__() імітує конструктор класу. Цей метод викликається під час створення екземпляра класу. 
Він приймає ключове слово self як перший аргумент, який дозволяє отримати доступ до атрибутів або методу класу.

Ми можемо передати будь-яку кількість аргументів під час створення об'єкта класу, залежно від визначення __init__(). 
Здебільшого він використовується для ініціалізації атрибутів класу. Кожен клас має бути конструктором, навіть якщо він просто покладається на конструктор за замовчуванням.
Найчастіше використовуваний метод — це метод __init__. Цей метод відповідає за ініціалізацію об'єкта. Коли ви створюєте об'єкт класу, спочатку створюється порожній об'єкт, який містить лише обов'язкові службові атрибути. 
Після цього (об'єкт вже створено) автоматично викликається метод __init__, який ви можете модифікувати під ваші потреби.

### 28. Чому у методі __init__ є аргумент self?

__init__ - метод, який викликається при створенні екземпляра класу, в ньому можна оголосити члени класу, 
а також виконувати будь-які інші дії (наприклад, збільшувати лічильник створених екземплярів)

self - перший аргумент будь-якого методу за згодою. При виклику методу self надається посилання на екземпляр, для якого був викликаний метод. 
Тобто, для методу класу завжди передається хоча б один аргумент - сам екземпляр (якщо не брати до уваги статичні методи). 
Приклад:

```bash
class Test:
    def __init__(self):
        self.a = 1
        self.b = 2

    def show_a(self):
        print(self.a)

    def show_b(self):
        print(self.b)
```
Оголосимо клас, створимо екземпляр та проведемо пару маніпуляцій

```bash
test_ex = Test()
test_ex.show_a()
Test.show_b(test_ex)
```
У першому випадку аргумент self задається неявно, а у другому явно. Але відмінностей у виконанні немає

### 29. Що таке приватні та захищені атрибути? Як вони працюють?
### 30. Чи можна отримати доступ до приватних атрибутів у Python?
### 31. Що таке менеджер контексту, навіщо він потрібний?
Менеджери контексту дозволяють виділяти та звільняти ресурси строго за потребою. 
Найпопулярніший приклад використання менеджера контексту – вираз with. 
Припустимо, у вас є дві пов'язані операції, які ви хочете виконати в парі, розмістивши між ними блок коду. 
Менеджери контексту дозволяють зробити саме це
Створення власних менеджерів контексту
Популярне завдання — це створення власних менеджерів контексту. 
Наприклад, ми пишемо клієнта до сервера, який має закрити сесію з сервером у будь-якому випадку. 
Для цього нам зручно буде створити менеджер контексту, який закриє з'єднання у будь-якому випадку.
У цьому нам допоможуть магічні методи, які відповідають за синтаксис with ... as ...:.

- __enter__ викликається, коли інтерпретатор заходить у контекст і те, що він поверне, буде записано в змінну після as;
- __exit__ викликається, коли інтерпретатор виходить із блоку менеджера контексту. Буде викликаний у будь-якому випадку.

# Git
### 1. Що це таке і навіщо він потрібний?
Git – розподілена система керування версіями.
Git застосовується для управління версіями в рамках колосальної кількості проектів з розробки програмного забезпечення, як комерційних, так і з відкритим вихідним кодом. 
Система використовується безліччю професійних розробників програмного забезпечення.

### 2. Що таке local і remote репозиторії?
### 3. Що таке commit?
Команда git commit робить для проекту знімок поточного стану змін, доданих до розділу проіндексованих файлів. 
Такі підтверджені знімки стану можна розглядати як «безпечні» версії проекту — Git їх не змінюватиме, поки ви явно не попросите про це. 
Перед виконанням команди git commit необхідно використовувати команду git add, щоб додати у проект («проіндексувати») зміни, які будуть збережені у коміті. 
Ці дві команди, git commit та git add, використовуються найчастіше.
### 4. Що таке гілка?
Гілка в Git - це простий переміщуваний покажчик на один з таких коммітів. За промовчанням, ім'я основної гілки в Git master. 
Як тільки ви почнете створювати комміти, гілка master завжди вказуватиме на останній комміт. 
Щоразу при створенні комміта покажчик гілки master буде пересуватися на наступний коміт автоматично.

### 5. Що таке pull-request/merge-request?

Merge Request та Pull Request це один і той же функціонал, який у різних репозитаріях просто називається по-різному, про це можна почитати тут. 
І те й інше позначає той самий процес, в GitHub і Bitbucket називають операцію pull request, тому що перша дія, яку здійснить людина, яка буде вливати собі правки з request це git pull, 
тоді як GitLab і Gitorious називають цю merge request , тому що фінальною дією буде злиття змін (git merge)
Якщо я не помиляюся, під капотом - те саме. GitLab оперує Merge Request, GitHub – Pull Request. 
Різниця скоріше смислова, адже GitLab призначений більше для використання всередині компанії, GitHub – опенсорс. 
Звідси випливає логіка: усередині компанії ми створюємо запит 
"Я ось наробив, хочу свою гілку залити в майстер девелопетц". 
А на гітхаб - "Я ось тут ваш продукт удосконалив, заберіть те чого я наробив".

### 6. Що таке merge?
Git Merge

Злиття - звичайна практика для розробників, які використовують систему контролю версій. 
Незалежно від того, чи створені гілки для тестування, виправлення помилок або з інших причин, злиття фіксує зміни в іншому місці. 
Злиття приймає вміст гілки джерела та поєднує їх з цільовою гілкою. 
У цьому процесі змінюється лише цільова гілка. Історія вихідних гілок залишається незмінною.
Плюси:

- простота;
- зберігає повну історію та хронологічний порядок;
- підтримує контекст гілки.

Мінуси:

- історія коммітів може бути заповнена (забруднена) безліччю коммітів;
- налагодження з використанням git bisect може стати складнішим.
### 7. Що таке rebase?
Git Rebase

Rebase - ще один спосіб перенести зміни з однієї гілки до іншої. 
Rebase стискає всі зміни в один "патч". Потім він інтегрує патч у цільову гілку.
На відміну від злиття, переміщення перезаписує історію, тому що вона передає завершену роботу з однієї гілки до іншої. 
У процесі усувається небажана історія

### 8. Що таке "Pull"?
Команда git pull використовується для вилучення та завантаження вмісту з віддаленого репозиторію та негайного оновлення локального репозиторію цим вмістом. 
Злиття віддалених вищих змін у локальний репозиторій - це звичайне завдання робочого процесу, що виникає при спільній роботі на основі системи Git. 
Команда git pull насправді є комбінацією двох інших команд: git fetch і git merge. 
На першому етапі git pull виконується команда git fetch, обмежена локальною гілкою, яку вказує HEAD. 
Відразу після завантаження вмісту команда git pull виконує злиття. 
Для злитого вмісту створюється новий коміт, а покажчик HEAD оновлюється і починає вказувати цей новий комит.

### 9. Чим rebase відрізняється від merge?
### 10. Що таке конфлікти? Чому вони виникають і як їх вирішувати?
### 11. Вміти користуватися командами: clone, commit, push, pull, merge, rebase

# Docker
### 1. Що таке контейнеризація? Навіщо вона потрібна?
Контейнеризація – це технологія, яка допомагає запускати програми ізольовано від основної операційної системи. 
Програма упаковується в спеціальну оболонку-контейнер, усередині якої середовище, необхідне для роботи.
Технологія потрібна:

- для ізольованого запуску додатків та робочих середовищ незалежно від системи та ПЗ, встановлених на конкретній машині;
- контролю ресурсів та зниження навантаження на систему;
- вирішення конфліктів, які можуть виникнути через те, що різні додатки потребують різних версій ПЗ або бібліотек;
- швидкого переміщення налаштованих додатків та середовищ з однієї машини на іншу;
- створення зручної робочої інфраструктури;
- прискорення процесу розробки та зниження ризику помилок;
- масштабування готових рішень;
- легкого управління складними додатками, середовищами та системами.

### 2. Чим контейнер відрізняється від віртуальної машини?
Схоже на перший погляд поняття — віртуалізація, створення віртуальної копії іншої ОС тому ж комп'ютері. Технології різняться між собою.
Віртуальна машина (ВМ) - абстракція на рівні фізичного обладнання, перетворює один сервер на кілька.
На кожній ВМ окрема гостьова ОС працює поверх ОС хоста з віртуалізованим доступом до базового обладнання.
Віртуальні машини з різними операційними системами можуть працювати на одному фізичному сервері: ВМ UNIX може працювати разом з ВМ Linux та ін. 
Система віртуалізації та мікроядро, що створюють та запускають віртуальні машини, називаються моніторами ВМ або гіпервізорами. 
Вони знаходяться між обладнанням та ВМ і необхідні для ізоляції ОС один від одного та віртуалізації сервера.

Контейнер – абстракція на рівні програми, що поєднує залежності та код.

Контейнери встановлюються на фізичний сервер та його ОС, наприклад Windows чи Linux. Вони відокремлюють вміст операційної системи. 
Контейнери легше, швидше розвертаються, вимагають менше оперативної пам'яті та потужностей, а також гнучкіші. 
Витрата ресурсів менша, швидкодія вища.
Віртуальні машини запускають будь-яке ядро операційної системи, незалежно від основної ОС. 
Контейнер повинен бути сумісним із ядром операційної системи сервера.

### 3. Що таке образ?

Образ Docker (Docker Image) – це незмінний файл, що містить вихідний код, бібліотеки, залежності, інструменти та інші файли, необхідні для запуску програми.
Через те, що образи призначені лише читання їх іноді називають знімками (snapshot). Вони представляють додаток та його віртуальне середовище у певний момент часу. 
Така узгодженість є однією з відмінних рис Docker. Він дозволяє розробникам тестувати та експериментувати програмне забезпечення у стабільних, однорідних умовах.
Оскільки образи просто шаблони, їх не можна створювати або запускати. Цей шаблон можна використовувати як основу для побудови контейнера. 
Контейнер - це, зрештою, просто образ. При створенні контейнера поверх образу додає шар, доступний для запису, що дозволяє змінювати його на власний розсуд.
Образ - це шаблон, основі якого створюється контейнер, існує окремо і може бути змінено. 
Під час запуску контейнерного середовища всередині контейнера створюється копія файлової системи (docker образу) для читання та записування.

### 4. Що таке том?

Том Docker це засіб для постійного зберігання інформації на віртуальній машині. 
Дані у томі зберігаються незалежно від контейнерів. Якщо ви видалите контейнер, то томи та дані в томах залишаться.
Створенням та управлінням томами займається Docker. 
Ось основні властивості томів Docker:

- Вони є засоби для постійного зберігання інформації.
- Вони самостійні та відокремлені від контейнерів.
- Ними можуть спільно скористатися різні контейнери.
- Вони дозволяють організувати ефективне читання та запис даних.
- Тому можна розміщувати на ресурсах віддаленого хмарного провайдера.
- Їх можна шифрувати.
- Їм можна надавати імена.
- Контейнер може організувати завчасне заповнення тома даними.
- Вони зручні для тестування.
Створювати томи в Dockerfile можна за допомогою формату JSON.

Крім того, томи можна створювати засобами командного рядка під час роботи контейнера.

### 5. Що таке мережа контейнера?
Спочатку давайте подивимося, як налаштована мережева модель Docker за замовчуванням. Тобто коли ви просто створюєте контейнер, йому присвоюється адреса і є можливість для доступу в інтернет без будь-яких додаткових зусиль з вашого боку.

Для цього Docker використовується мережевий міст (bridge), зазвичай його ім'я в системі — docker0. Для кожного контейнера створюється свій віртуальний мережний інтерфейс, він підключається до мережі за допомогою bridge.

На схемі підключення виглядає так:

| Додаток -> ethernet -> | -> virtual ethernet -> bridge -> ethernet/wifi interface |

| Контейнер | Хост |

Метод мережного мосту досить універсальний для віртуальних машин, оскільки він простий та зручний.

### 6. Які види мереж бувають?

Огляд мереж Docker
Bridge: у цій мережі контейнери запускаються за промовчанням. ...
Host: цей драйвер дає контейнеру доступ до власного простору хоста (контейнер бачитиме і використовуватиме той самий інтерфейс, що й хост).
Macvlan: цей драйвер дає контейнерам прямий доступ до інтерфейсу та суб-інтерфейсу (vlan) хоста.

### 7. Навіщо потрібний docker-compose?

Docker Compose — інструментальний засіб, що входить до складу Docker. Воно призначене для вирішення завдань, пов'язаних із розгортанням проектів.
Docker Compose використовується для одночасного керування кількома контейнерами, що входять до складу програми. 
Цей інструмент пропонує ті ж можливості, що й Docker, але дозволяє працювати з більш складними програмами.

## Бази даних

### 1. Що таке бази даних і навіщо вони потрібні?
База даних (БД) - це програма, яка дозволяє зберігати та обробляти інформацію у структурованому вигляді.
### 2. Які типи баз даних бувають?



## Django/ BackEnd

### 1. Як би Ви описали Джанго?

Приклад: “Django – це фреймворк для веб-розробки на Python, який спрощує процес веб-розробки. 
Він пропонує набір модулів, які ви можете використовувати у власних проектах, дозволяючи користувачам зосередитися на розробці нових компонентів програми. 
Цей фреймворк слідує принципам швидкої розробки, які дозволяють користувачам виконувати кілька ітерацій одночасно».


### 2. Які переваги Django?


Я виявив багато переваг використання Django, таких як загальна універсальність фреймворку. 
Можливість додавати різні функції до програм, залишаючи місце для великої кількості налаштувань, була дуже корисною в багатьох проектах. велика перевага, тому що вони дозволяють розробляти безліч різних веб-сайтів. 
Іншою перевагою є масштабованість платформи. Django дозволяє легко розподіляти додаток по кількох серверах за допомогою кластеризації. 
Адміністративний інтерфейс спрощує автентифікацію користувачів та автоматичну перевірку вхідних даних. та зручно».


### 3. Що таке архітектура Django?
  «Django слідує структурі шаблону представлення моделі (MVT) для архітектури, яка заснована на архітектурі контролера представлення моделі (MVC). 
На відміну від MVC структура обробляє сам контролер. Рівень моделі містить всю інформацію про дані, включаючи як отримати доступ до нього і перевірити його, в той час як рівень подання допомагає зв'язати модель і шаблон.
Його останній рівень, відомий як рівень шаблону, визначає представлення веб-сторінки або цифрового документа. 
Розробник надає модель, представлення та шаблон і зіставляє його з URL-адресою, яку Django потім відправляє користувачеві».

### 4. У чому різниця між проектом та програмою в Django?

Приклад: «Проект являє собою весь додаток Django, а додаток – це модуль у проекті Django, який зазвичай виконує різні завдання та є самодостатнім. 
Проект може включати множину додатків, не пов'язаних один з одним. Наприклад, проект може бути весь мій веб-сайт, і я маю різні програми для частин мого проекту, наприклад, додаток для таблиць ранжування».
### 5. Опишіть етапи життєвого циклу запиту-відповіді Django.

“Django обробляє запити, які отримує сервер. Різні проміжні програми обробляють запит по одному, і якщо проміжне програмне забезпечення безпеки виявляє, що запит несправний, запит не просувається вперед. 
Якщо це не так, проміжне програмне забезпечення автентифікації опрацьовує запит автентифікації.

На наступному кроці проміжне програмне забезпечення передає запит маршрутизатору URL-адрес, який витягує URL-адресу з запиту і намагається порівняти його з певними URL-адресами. 
Після зіставлення він викликає еквівалентну функцію перегляду, яка може отримати доступ до файлів із запиту. Після того, як функція перегляду звертається до файлів, надходить відповідь у вигляді HttpResponse. 
Як і запит, відповідь проходить через проміжне програмне забезпечення відповіді, яке надсилає його назад до браузера**».

### 6. Як ви обробляєте URL-адресу Django?

Щоб підтримувати чисту URL-адресу Django, я зазвичай зосереджуюсь на певній кількості категорій, щоб спростити редагування URL-адрес за необхідності. 
Я також використовую повні слова в URL-адресі і структурую його ієрархічно, що робить сайт зручнішим для користувача. дружній. 
Оскільки Django заснований на файлах cookie, простіше уникати ідентифікаторів сеансів в URL-адресах, які містять конфіденційну інформацію




